# protoc-gen-typhon

This is a `protoc` plugin to generate Typhon clients for our services, based on service descriptions in Protobuf files.


### Demo

If you want to try this, quickly drop `--typhon_out=$GOPATH/src` into your `bin/generate_protobufs`:

```diff
-find $ROOT -maxdepth 3 -type f -name "*.proto" -exec echo Compiling {} ... \; -exec protoc --proto_path=$GOPATH/src --go_out=$GOPATH/src {} \;
+find $ROOT -maxdepth 3 -type f -name "*.proto" -exec echo Compiling {} ... \; -exec protoc --proto_path=$GOPATH/src --go_out=$GOPATH/src --typhon_out=$GOPATH/src {} \;
```
(Make sure there's only one `{}`!)


## Syntax

A service descriptor goes at the top of the existing `foobar.proto` file for a service.

Services and RPCs have the following options:

```proto
// Existing proto header lines
syntax = "proto3";
package foobarproto;

// This import is required for the `handler` and `router` options to work
import "github.com/monzo/wearedev/tools/protoc-gen-typhon/proto/typhon.proto";

// The foo-bar service is really cool, yo?
service foo_bar {
    // optional: inferred from the service name above
    // (required if your service name contains dots)
    option (router).name = "service.foo-bar";

    // Do this thing, and return that other thing. 
    rpc DoSomeThing(PUTMyEndpointRequest) returns (PUTMyEndpointResponse) {
        // optional: inferred from PUTMyEndpointRequest, or defaults to POST
        option (handler).method = "PUT"; 

        // required
        option (handler).path = "/path/to/my_endpoint";

        // optional: set this to true only when the Send() method would clash
        option (handler).omit_proto_method = false;
    }
}
```

Usually most options can be omitted, apart from `path`, which is required.

Omitting the method from the RPC name is preferred.

Use of `omit_proto_method` should be very rare; it's only required when there is more than one endpoint using the same Request proto, and so the `Send()` method cannot be registered without causing a compile error.


## Usage

The generated file, `proto/foobar.typhon.go`, contains client helper functions.

Use them like so:

```golang
future := foobarproto.PUTMyEndpointRequest{
    ArgumentOne: 1,
}.Send(ctx)

body, err = future.DecodeResponse()
if err != nil {
    return err
}
```

**Alternatively**, you can call the endpoint without using the Send() method.

```golang
future := foobarproto.DoSomeThing(ctx, &foobarproto.PUTMyEndpointRequest{
    ArgumentOne: 1,
})
```

The generated client helpers protect you against HTTP method and path mistakes. If an endpoint is deleted, clients from any other services relying on it will fail to compile.

The proto file is intended to service a dual purpose as **documentation** for all service endpoints.

The `Send()` method and `DoSomeThing()` function both include Go comments, copied from the comment above the rpc directive in the proto file. If you use a Go IDE, hopefully it should pick up this documentation.


## Contributing

Here's a brief overview of the code in this repository:

  - `protoc-gen-typhon` is the program itself, that generates clients from proto descriptions.

    (This is the executable that you `go install`.)

  - `proto` contains `typhon.proto`, which describes 

    You have to import this into your service's `.proto` file, so that protoc can understand the `handler` and `router` options.

  - `gen` contains helper libraries, lifted from [twitchtv/twirp/internal/gen](https://github.com/twitchtv/twirp/tree/dccdd41ffb79c98af663f74a528488f5a035b47b/internal/gen) and their import paths changed.

    Twirp is Apache 2.0 licensed.

    Some of these files were in turn taken from `golang/protobuf` by Twitch, and so are `Copyright 2010 The Go Authors`.


### Future Work

It would be cool to extend this: for example

* to generate server helpers;
* to generate mock endpoints helpers


### Why isn't this included in the main Typhon repository?

Good question! If we like this, we could end up open-sourcing it along with the rest of Typhon.


### Internals

Here's an example of what a full `foobar.typhon.go` looks like: 

```golang
// Code generated by protoc-gen-typhon v5.0.0, DO NOT EDIT.
// source: github.com/monzo/wearedev/service.foo-bar/proto/foobar.proto

/*
Package foobarproto is a generated typhon stub package.
This code was generated with github.com/monzo/wearedev/tools/protoc-gen-typhon/protoc-gen-typhon v5.0.0.

It is generated from these files:
	github.com/monzo/wearedev/service.foo-bar/proto/foobar.proto
*/
package foobarproto

import context "context"

import typhon "github.com/monzo/typhon"

// The foo-bar service is really cool, yo?

// =====================
// service.foo-bar client
// =====================

// ========================
// PUT /path/to/my_endpoint
// ========================


// Do this thing, and return that other thing.
func DoSomeThing(ctx context.Context, body *PUTMyEndpointRequest) *DoSomeThingFuture {
	return &DoSomeThingFuture{Future: typhon.NewRequest(ctx, "PUT", "/service.foo-bar/path/to/my_endpoint", body).Send()}
}

// Do this thing, and return that other thing.
func (body PUTMyEndpointRequest) Send(ctx context.Context) *DoSomeThingFuture {
	return DoSomeThing(ctx, &body)
}

type DoSomeThingFuture struct {
	Future   *typhon.ResponseFuture
	Response *typhon.Response
}

func (f *DoSomeThingFuture) Done() {
	if f.Response == nil {
		rsp := f.Future.Response()
		f.Response = &rsp
	}
}

func (f *DoSomeThingFuture) DecodeResponse() (*PUTMyEndpointResponse, error) {
	f.Done()
	body := &PUTMyEndpointResponse{}
	if err := f.Response.Decode(body); err != nil {
		return nil, err
	}
	return body, nil
}
```
